**Name**: Anukul Pokharel

**CRN**: 021-310

# Block Arrangement Problem

---

## Problem Statement

Implement a heuristic function for a block arrangement problem with four blocks labeled A, B, C, and D, arranged in a linear stack. The goal is to arrange the blocks in the order `[A, B, C, D]` from top to bottom. Use a heuristic that counts the number of blocks out of place compared to the goal state. Solve the problem using the Hill Climbing algorithm.

**Input**: Initial stack (e.g., `[C, A, D, B]`)  
**Output**: Sequence of moves (swap two adjacent blocks) to reach the goal state.  
**Requirement**: Display the initial stack, heuristic values for each state, and the solution path (or indicate if the algorithm gets stuck).

---

## Implementation

The solution is implemented in Python and uses a simple **Hill Climbing** algorithm:
- **Heuristic**: Number of blocks out of place compared to the goal `[A, B, C, D]`.
- **Neighbors**: Generated by swapping adjacent blocks.
- At each step, the algorithm moves to the neighbor with the lowest heuristic.
- If no better neighbor is found, the algorithm terminates (may get stuck in a local minimum).

---

## Example

**Initial Stack**:
```
['C', 'A', 'D', 'B']
```

**Sample Output**:
```
Initial Stack: ['C', 'A', 'D', 'B']
Initial Heuristic: 4

Evaluating: ['A', 'C', 'D', 'B'] | Heuristic: 3
Evaluating: ['C', 'D', 'A', 'B'] | Heuristic: 4
Evaluating: ['C', 'A', 'B', 'D'] | Heuristic: 3

Move: swap(0, 1)
Current Stack: ['A', 'C', 'D', 'B']
Current Heuristic: 3
...

Goal reached!
Solution path: ['swap(0, 1)', 'swap(1, 2)', 'swap(2, 3)', ...]
```

---

## Output
![OPBlock]()

---
# 8 Puzzle Problem

## Problem Statement

Implement a heuristic function for the 8-puzzle problem (3x3 grid with tiles numbered 1–8 and one blank tile). Use Manhattan distance as the heuristic to estimate the cost to the goal state (tiles in order 1–8 with the blank at the bottom-right). Solve the puzzle using Breadth-First Search to find the optimal solution.

**Input**: Initial state (e.g., `[[1, 2, 3], [4, 0, 5], [7, 8, 6]]`, where 0 is the blank tile)  
**Output**: Sequence of moves (up, down, left, right) to reach the goal state  
**Requirement**: Display the initial state, heuristic values for explored states, and the optimal solution path

---

## Implementation

This project solves the 8-puzzle using **Breadth-First Search (BFS)**:
- A **Manhattan distance** heuristic function is used to measure how far each state is from the goal (though BFS doesn't use it for decision-making, it's shown for reference).
- The algorithm explores all states level by level and ensures the **shortest (optimal) path** to the solution is found.

---

## Example

**Initial State**:
```
[[1, 2, 3],  
 [4, 0, 5],  
 [7, 8, 6]]
```

**Sample Output**:
```
Initial State:
[1, 2, 3]
[4, 0, 5]
[7, 8, 6]
Initial Manhattan Distance: 2

Explored Move: right
[1, 2, 3]
[4, 5, 0]
[7, 8, 6]
Manhattan Distance: 1

Explored Move: down
[1, 2, 3]
[4, 8, 5]
[7, 0, 6]
Manhattan Distance: 2

...

Goal reached!
Optimal solution path (moves):
['right', 'down', 'left']
```

---

## Output
![OP8Puzzle]()


---
